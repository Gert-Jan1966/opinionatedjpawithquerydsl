# No further step without Querydsl {#querydls}

To put it simply -- [Querydsl](www.querydsl.com) is a library that -- from programmer's
perspective -- works like a more expressive and readable version of *Java Persistence Criteria
API*. Internally it first generates JPQL and the rest from there is handled by the JPA provider.
Querydsl can actually talk to many more back-ends: SQL, Hibernate directly, ... and many
more, but we will focus on Querydsl over JPA here. To use it goes in these steps:

* declare the dependency for Querydsl library and to its annotation processor,
* add a step in your build to generate metamodel classes,
* and write queries happily in sort of criteria-like way.

But Criteria API also lets you use generated metamodel, so what's the deal? Why would I introduce
non-standard third-party library when it does not provide any additional advantage? If you even
hate this idea, then you probably can stop reading this book -- or you can translate all my
Querydsl code into JPQL or Criteria yourself, which is perfectly doable, of course! Querydsl does
not disrupt the stack under it, it is "just" slapped over the JPA to make it more convenient.

Querydsl brings in a [domain-specific language](https://en.wikipedia.org/wiki/Domain-specific_language)
(or DSL) in the form of its fluent API. It happens to be so-called internal DSL because it's still
embedded in Java, it's not different language per se. This fluent API is much more readable and
convenient than Criteria API which has couple of advantages.

DSL is a language of some specific domain -- in this case it's a query language very close to JPQL
or SQL. It builds on a generated metamodel a lot. API of this metamodel is well-though and takes
type-safety to a higher level compared with Criteria API. This not only gives us compile-time
checks for our queries, but also offers even better auto-completion in IDEs.


## Simple example with Querydsl

Let's be concrete now -- but also very simple. We have a class `Dog`, each dog has a `name`
and we will query by this `name`. Assuming we got hold of `EntityManager` (variable `em`) the code
goes like this:

{title="Querydsl simple example", lang=java}
~~~
List<Dog> dogs = new JPAQueryFactory(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .where(QDog.dog.name.like("Re%"))
//.where(QDog.dog.name.startsWith("Re")) // alternative
  .fetch();
~~~

Both `where` alternatives produce the same result in this case, but `startsWith` may communicate
the intention better, unless you go for `like("%any%")` in which case `contains` would be better.
If you are provided input values for `like`, leave it. If you can tell from the logic that more
specific name for the operation is better, go for it.

This is a very subtle thing, but we can see that this DSL contains variations that can communicate
our intention more clearly. Criteria API sticks to `like` only, because that is its internal model.
Other thing is how beautifully the whole query flows. In version 4.x the fluent API got even closer
to JPQL/SQL semantics, it starts with `select` (what) and ends with `fetch` which is a mere
signal to deliver the results. As with any other fluent API, you need a terminal operation.
In previous versions you would have no `select` because it was included in a terminal operation,
e.g. `list(QDog.dog)`. Newer version is one line longer, but closer to the target domain
of query languages.

D> And yes, I wrap the code like this even in IDE where I could afford 160 characters or more.
D> That, however, is completely different topic and there are people that can explain it [much
D> better](http://www.infoq.com/presentations/7-ineffective-coding-habits).
D> The whole linked presentation is good (and fun!), but at least watch the part from 17m25s.


## Comparison with Criteria API

Both Querydsl and Criteria API are natural fit for dynamic query creation. Doing this with JPQL
is rather painful. Imagine a search form with separate fields for a person
entity, so you can search by name, address, date of birth from--to, etc. We don't want to add
the search condition when the respective input field is empty. If you have done this before
with any form of query string concatenation then you probably know the pain. In extreme cases
of plain JDBC with prepared statement you even have to write all the `if`s twice -- first to add
`where` condition (or `and` for any next one) and second to set parameters. Technically you can
embed the parameter values into the query, but let's help the infamous
[injection](https://en.wikipedia.org/wiki/SQL_injection) vulnerability get off the top of the
[OWASP Top 10 list](https://www.owasp.org/index.php/Top_10_2013-Top_10).

T> If you ever need to construct JDBC statements again -- and there are cases when JPA is not
T> enough, like streaming a really long list of results -- you definitely want to use something like Spring's
T> [`JdbcTemplate`](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/jdbc.html#jdbc-JdbcTemplate).
T> This still leaves putting the query together to you, but allows you to add each parameter
T> value at the time when you add the where part. And also takes away many low-level JDBC concerns.
T>
T> BTW: Do you remember *JPA 1.0*? It didn't have any Criteria API!

Let's see how query for our dogs looks like with Criteria API -- again starting from `em`:

{title="Criteria API simple example", lang=java}
~~~
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Dog> query = cb.createQuery(Dog.class);
Root<Dog> dog = query.from(Dog.class);
query.select(dog)
  // this is the only place where we can use metamodel in this example
  .where(cb.like(dog.get(Dog_.name), "Re%"));
  // without metamodel it would be:
//.where(cb.like(dog.<String>get("name"), "Re%"));
List<Dog> dogs = em.createQuery(query)
  .getResultList();
~~~

Let's observe now:

* First you need to get `CriteriaBuilder` from existing `em`. You might "cache" this into
a field but it may not play well with EE component model, so I'd rather get it before using.
This should not be heavy operation, in most cases entity manager holds this builder already
and merely gives it to you (hence `get` and not `new` or `create`).
* Then you create an instance of `CriteriaQuery`.
* From this you need to get a `Root` object representing content of a `from` clause.
* Then you use the `query` in a nearly-fluent fashion. Version with metamodel is presented
with alternative without it in the comment.
* Finally, you use `em` again to get a `TypedQuery` based on the `CriteriaQuery` and we ask it
for results.

D> Creators of JPA decided not to go with fluent API and it shows. If you read this for a while
D> you'll get the meaning, especially when you're used to it, but our mind needs bigger mental
D> shift to get the meaning compared with the Querydsl version. Clearly, signal-to-noise ratio
D> is much lower too.

While in case of Criteria API you don't need to generate metamodel from the entity classes,
in Querydsl this is not optional. But using metamodel in Criteria API is advantageous anyway
so the need to generate the metamodel for Querydsl using annotation processor can hardly be
considered a drawback. It can be easily integrated with Maven or other build as demonstrated
in the [companion sources](https://github.com/virgo47/opinionatedjpawithquerydsl/blob/master/manuscript/00-basic/pom.xml)
to this book or [documented](http://www.querydsl.com/static/querydsl/4.0.7/reference/html/ch02.html#d0e127)
on Querydsl site.

For another comparison of Querydsl and Criteria API, you can also check the
[original blog post](http://blog.mysema.com/2010/04/querydsl-as-alternative-to-jpa-2.html)
from 2010. Querydsl was much younger then (version 1.x) but the difference was striking already.


## Comparison with JPQL

Comparing Querydsl with Criteria API was rather easy as they are in the same ballpark. Querydsl,
however, with its fluency can be compared to JPQL although it can't match it completely. After all
JPQL is non-Java DSL, even though it typically is embedded in Java code. Let's see JPQL in action
first to finish our side-by-side comparisons:

{title="JPQL simple example", lang=java}
~~~
List<Dog> dogs = em.createQuery(
  "select d from Dog d where d.name like :name", Dog.class)
  .setParameter("name", "Re%")
  .getResultList();
~~~

This is it! Straight to the point, and you can even call it fluent! Probably the best we can do
with Querydsl is adding one line to introduce shorter "alias" like this:

{title="Querydsl simple example with alias", lang=java}
~~~
QDog d = new QDog("d1");
List<Dog> dogs = new JPAQueryFactory(em)
  .select(d)
  .from(d)
  .where(d.name.startsWith("Re"))
  .fetch();
~~~

We could use `QDog.dog` as the value, or here I introduced new variable and named it `d1`. This
name will appear in generated JPQL that looks a little bit different from the JPQL in example
above:

  select d1 from Dog d1 where d1.name like ?1 escape '!'

There is a subtle difference in how Querydsl generates `like` clause -- which, by the way, is fully
customizable using Querydsl templates. But you can see that alias appears in JPQL, although neither
EclipseLink nor Hibernate bother to translate it to generated SQL for your convenience.

Now if we compare both code snippets above (alias creation included) we get a surprising result --
there are more characters in the JPQL version! But this is really nit-picking, line/char here or
there. Querydsl expresses the JPQL extremely well (especially in 4.x version) and brings all of
possibilities of dynamic query creation.

If you're familiar with JPQL more than me (which is not that hard, after all) you may ask about
named queries. Here I admit right away, that Querydsl necessarily introduces overhead (see
[cons](#querydsl-cons) section), but when it comes to query reuse from programmers perspective,
there is an answer called...


## Detached queries

TODO: Query objects?
Detached query can be attached to current entity manager.


## And the cons? {#querydsl-cons}

TODO: Performance comparison?
Documentation, good - but not complete (but suberb support on stackoverflow, mailing-list, github, ...)
Additional dependency, non-standard


## Be explicit with aliases

http://stackoverflow.com/questions/6385036/querydsl-generated-classes-not-able-to-access-second-level-elements-for-querying


## Tricky predicate parts

TODO: BooleanBuilder, and/or and other prioritized operations serialization, ...

## More

http://www.slideshare.net/timowestkamper/querydsl-overview-2014
Slides about older version 3, but except for the fluent API changes the concept is the same.