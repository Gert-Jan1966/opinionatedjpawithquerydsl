{mainmatter}

-# JPA Good Times, Bad Times {#part-jpa-good-bad}

The biggest trouble with JPA (and ORM in general) is that it is hard. Harder than people realize.
The topic is complex, yet the solutions somehow make it look easier than it really is. JPA is part
of Java EE, hence people prefer it. If you go the other way (Spring) you use it again, either as
JPA or directly using one of the providers (like *Hibernate*). There are also no widespread
alternatives, because JDBC is just way too low-level.

JPA/ORM also somehow makes people believe they don't need to understand *SQL*. Or even *JPQL* for
that matter -- and it shows (pain)fully both in the code and in runtime too, typically in the
performance aspects.

Technology like this deserves to be studied deeper than it usually is. It cannot be just slapped
on the application. Yet, that is what I mostly see and all the false, but implied, promises deliver.
JPA is now one of many embodiments of "EE" -- or enterprise software. Applications are bigger and
more complex than than they need to be and slower, of course. Developers map the entities but they
don't follow through and don't investigate and let entropy do the rest of the work instead.

JPA is not perfect and I could name couple of things I'd love to see there. Many of them may not
be right for JPA philosophy, others would probably help tremendously, but in any case we are
responsible to do our best to learn about such a key technology -- that is if we use it. It reads
and writes data from/to our databases which is a crucial thing for most enterprise applications!
So let's talk about the limits, let's talk about implications, about lazy loads and their
consequences, etc. Don't "just fix it with OSIV" (open session in view).

In the following chapters we will talk what is really good about JPA, what is missing and what
is rather limiting (if I want to avoid "plain bad" or some other unfairly harsh statement).


# Good Parts

JPA standard, ...