# Tuning ORM down {#ch-tuning-orm-down}

Full-blown object-relational mapping maps database foreign keys as relations between objects.
Instead of `Integer breedId` you have `Breed breed` where mapping information provides all the
necessary low-level information about the foreign key. This mapping information can be stored
elsewhere (typically XML mapping file) or as annotations directly on the entity (probably more
popular nowadays). Relations can be mapped in any direction (even in reverse), for one or both
directions (then you choose which one is the owner's side, which is kinda more "in control" of
the relationship) and in any cardinality (with annotations `@OneOnOne`, `@OneToMany`, `@ManyToOne`
and `@ManyToMany`). Mapping foreign keys as relations is probably the most pronounced feature of
an ORM. And I'm going to make a case against some of it.

Most of the points I'm going to explain somehow revolve around two rules:

* **Be explicit.** For instance don't leave persistence context (session) open after you leave
the service layer and don't wait for the presentation layer to load something lazily. Make explicit
contract and fetch eagerly what you need for presentation, just like you would with plain SQL
(but still avoiding ORM syndrome "load the whole DB"). Also, don't rely on caches blindly.
* **Don't go lazy.** Or at least not easily. This obviously stems from the previous point, but
goes further. Lazy may save some queries here and there, but in practice we rely on it too much.
In most cases we can be explicit, but we're lazy to be so (so let's not go lazy ourselves either).
There are places where `FetchType.LAZY` means nothing to JPA. Oh, they will say it's a hint for
a provider, but it's not guaranteed. That's nothing for me. Let's face it -- any *to-one* mapping
is eager, unless you add some complexity to your system to make it lazy. It's not lazy because you
annotate it so, deal with it.

## Price for relations

For me the biggest problem is that JPA does not provide any convenient way how to stop cascading
loads for `@ManyToOne` and `@OneToOne` (or just *to-one* in this book) relationships. I don't mind
*to-many* relations, they have their twists, but at least their lazy works.
But *to-one* typically triggers find by id. If you have a `Dog` that has an `owner` (type `Person`)
and is of specific `Breed` you must load these two things along with a dog. Maybe they will be
joined by the JPA provider (Hibernate does it), maybe not (EclipseLink), maybe they are already
in second-level cache and will be "loaded" nearly "for free". All these options should be seriously
considered, analyzed and proved before you can say that you know what is going on in your
application.

And it just starts there, because `Person` has an `Address` which -- in case of a rich system --
may further point to `District`, `County`, `State` and so on. Once I wanted to change something
like `Currency` in a treasury system. It loaded around 50 objects -- all of them across these
*to-one* relations. All of this may happen when you naively want change a single attribute in that
currency. In SQL terms, that's an update of a single column for a single row.

When you insert or update a `Dog` you can use `em.getReference(clazz, id)` to get a `Breed` object
containing only id of the breed. This effectively works as a wrapped foreign key (FK). Heck, you
can just `new` an empty `Breed` and set its id, you don't even have to ask `em` for the reference.
But if you do this, that `Dog` is probably managed anyway which means it loaded previous values
for all FKs (cascading further on). Should you just use JPQL update and possibly remove all dogs
from the second-level cache? How ORM is that?

Why JPA doesn't provide better fetch control for finds? I want to work with this `Dog` object now,
I'm not interested in its relations, just wrap those FK values into otherwise empty entity objects
(like references) and let me do my stuff! How I wished I could just map raw FK value instead of
relation... actually, you can, but while you are able to related object explicitly (find by id),
you can't join on that relationship. Or can you?

There are little to no examples of this, because JPA 2.0 could not do that. All the joins were
implicit and without the mapping (`@One/ManyToOne/Many`) it simply dit not work. I actually
wandered "why can't I join on any value?!" for long time. And then, with JPA 2.1 out in a wild for
about a year, I discovered that I indeed **can** `JOIN` on any condition -- and that way I can join
with raw FK. This ultimately led me to some extreme measures and I got rid of *to-one* mappings
and never looked back.

So that is what the chapter [Moving away from *to-one* relationships](#ch-away-from-to-one) is
about. Other points are much less radical compared to this one. Long before I learnt that being
explicit and less lazy is definitely better and we will talk about it in other sections.


## How does this affect my domain model?

I stated that this book will not be about architecture, but this is the part where we have to
tackle it a bit. If we talk about [domain model](https://en.wikipedia.org/wiki/Domain_model), we
probably also talk about [domain driven design](https://en.wikipedia.org/wiki/Domain-driven_design)
(DDD) best described in [DDD](#bib-ddd). I can't claim experience with DDD because I never saw it
in practice, but it must work for some, reportedly especially for complex business domains with
lots of rules, etc. Reading [PoEAA](#bib-poeaa) it is obvious that there's a lot of synergy
between DDD and ORM. One may even ask whether to use ORM without DDD at all. And I can't answer
that, sorry.

[PoEAA](#bib-poeaa) recommends other patterns for simpler domain problems (*Transaction Script*,
*Table Module*) with related data source patterns (*Table Data Gateway*, *Row Data Gateway*
or *Active Mapper*). There are some newer architectural patterns as well, like *Command Query
Responsibility Segregation* ([CQRS](http://martinfowler.com/bliki/CQRS.html)) or *Data, context
and interaction* ([DCI](https://en.wikipedia.org/wiki/Data,_context_and_interaction)), both of them
perfectly usable with object-oriented languages, but not necessarily for every problem.

Back to domain, though. One anti-pattern often mentioned in relation to ORM/JPA is called
(Anemic domain model)[http://www.martinfowler.com/bliki/AnemicDomainModel.html]. Let's quote
master Martin Fowler a bit again:

{icon=quote-right}
G> In essence the problem with anemic domain models is that they incur all of the costs of a domain
G> model, without yielding any of the benefits. The primary cost is the awkwardness of mapping to
G> a database, which typically results in a whole layer of O/R mapping. This is worthwhile iff you
G> use the powerful OO techniques to organize complex logic. By pulling all the behavior out into
G> services, however, you essentially end up with Transaction Scripts, and thus lose the advantages
G> that the domain model can bring. As I discussed in P of EAA, Domain Models aren't always the
G> best tool.

TODO:
* Domain model over entity model? SRP...
* Do I incur all of the costs when I tune it down? For me *to-one* was most costly.
* One thing I respect on Fowler et al. is that they try to balance costs/benefits and they neither
push ORM always forward nor do they criticize it all the time without offering real alternatives
for the complex cases.
* Let's accept using entities as "structs" or [DTOs](https://en.wikipedia.org/wiki/Data_transfer_object)
-- it is still far more advanced compared to a `ResultSet` and similar low-level patterns. We
have dumb object (anemic model), but we can utilize that in a domain if we need to. Maybe we should
go for "dumb-object to domain-object" mapping instead. In any case we can hardly get rid of all
the notions of data store we use. Any "total abstraction" must lead to some mismatch -- and
typically also to even bigger performance penalty.


## Love and hate for ORM

* Ted Neward: http://blogs.tedneward.com/post/the-vietnam-of-computer-science/
  * Query-by-API is much better nowadays, state of the art technologies like Querydsl have very
  rich fluent API that is also very compact (definitely not "much more verbose than the traditional
  SQL approach"). Also both type safety and testing practices are much more developed.
  * Still, written up in 2006 (and referencing discussions two years before that) this post
  shows how much was known about ORM troubles already. It wasn't so young subject after all.
  Since then we merely smoothed out some rough edges, added more options (small gap compared to
  SQL), developed better tools around (like Querydsl) and standardized it (JPA) -- but virtually
  all the concerns Ted mentioned are still valid.
* Jeff Atwood: http://blog.codinghorror.com/object-relational-mapping-is-the-vietnam-of-computer-science/
* Martin Fowler: http://martinfowler.com/bliki/OrmHate.html
* Laurie Voss: http://seldo.com/weblog/2011/08/11/orm_is_an_antipattern
* Yegor Bugayenko: http://www.yegor256.com/2014/12/01/orm-offensive-anti-pattern.html and
https://www.youtube.com/watch?v=DEqcn4-freM (Yegor's solution to many problems is to put the
the technology right into the object, often all the technologies. There is no SRP in that.)

Other problems:
* monitoring of SQL from JPA application is difficult (it's kinda "elsewhere") and the
interaction with the SQL itself has a lot of overhead as well (but this is complex topic anyway,
JDBC proxy driver is possibility, but how to connect to the business logic or place where it
happens?)
* updates of all columns when just one was changed (not inherent JPA problem, but happens)
* bugs cross-fire, different providers have different bugs, but all are show-stoppers for
a project

Alternatives sometimes bash ORM on false grounds though:
* Complaint about using any QL on business level is completely off, as it should be hidden
somewhere else. Where? Maybe in some `User` object if it is *Active Record* pattern. Maybe in
`UserDao`. In any case, it is possible to change well wrapped access to other underlying storage.
I doubt it's much easier to switch from RDBMS to something completely else when you're not using
ORM when you design the rest of the system equally well.

## Caching

* complexity of ORM/JPA caching (query vs 2^nd^-level cache, provider settings)
* DB has its caches too
* anti-patterns: caching returned JPA entities with JSR-107/Spring (first time they are managed,
next time they are not)
* explicit application caching