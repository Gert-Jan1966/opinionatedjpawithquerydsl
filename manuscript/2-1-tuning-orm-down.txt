# Tuning ORM down {#ch-tuning-orm-down}

Full-blown object-relational mapping maps database foreign keys as relations between objects.
Instead of `Integer breedId` you have `Breed breed` where mapping information provides all the
necessary low-level information about the foreign key. This mapping information can be stored
elsewhere (typically XML mapping file) or as annotations directly on the entity (probably more
popular nowadays). Relations can be mapped in any direction (even in reverse), for one or both
directions (then you choose which one is the owner's side, which is kinda more "in control" of
the relationship) and in any cardinality (with annotations `@OneOnOne`, `@OneToMany`, `@ManyToOne`
and `@ManyToMany`). Mapping foreign keys as relations is probably the most pronounced feature of
ORM. And I'm going to make a case against some of it.

Most of the points I'm going to explain somehow revolve around two rules:

* **Be explicit.** For instance don't leave persistence context (session) open after you leave
the service layer and don't wait for the presentation layer to load something lazily. Make explicit
contract and fetch eagerly what you need for presentation, just like you would with plain SQL
(but still avoiding ORM syndrome "load the whole DB"). Also, don't rely on caches blindly.
* **Don't go lazy.** Or at least not easily. This obviously stems from the previous point, but
goes further. Lazy may save some queries here and there, but in practice we rely on it too much.
In most cases we can be explicit, but we're lazy to be so (so let's not go lazy ourselves either).
There are places where `FetchType.LAZY` means nothing to JPA. Oh, they will say it's a hint for
a provider, but it's not guaranteed. That's nothing for me. Let's face it -- any *to-one* mapping
is eager, unless you add some complexity to your system to make it lazy. It's not lazy because you
annotate it so, deal with it.

## Price for relations

For me the biggest problem is that JPA does not provide any convenient way how to stop cascading
loads for `@ManyToOne` and `@OneToOne` (commonly named *to-one* in this book as you probably
noticed) relationships. I don't mind *to-many* relations, they have their twists, but at least
their lazy works. But *to-one* typically triggers find by id. If you have a `Dog` that has an
`owner` (type `Person`) and is of specific `Breed` you must load these two things along with a dog.
Maybe they will be joined by the JPA provider (Hibernate does it), maybe not (EclipseLink), maybe
they are already in second-level cache and will be "loaded" nearly "for free". All these options
should be seriously considered, analyzed and proved before you can say that you know what is going
on in your application.

And it just starts there, because `Person` has an `Address` which -- in case of a rich system --
may further point to `District`, `County`, `State` and so on. Once I wanted to change something
like `Currency` in a treasury system. It loaded around 50 objects -- all of them across these
*to-one* relations. This may happen when you naively want to change a single attribute in that
currency. In SQL terms, that's an update of a single column for a single row.

When you insert or update a `Dog` you can use `em.getReference(clazz, id)` to get a `Breed` object
containing only id of the breed. This effectively works as a wrapped foreign key (FK). Heck, you
can just `new` an empty `Breed` and set its id, you don't even have to ask `em` for the reference.
In case of update you will not save much as that `Dog` is probably managed already anyway. You
can either update managed entity -- which means it loaded previous values for all *to-one* FKs
cascading as far as it needed -- or you can try to *merge* the entity -- but this works only if
you overwrite it completely, it's not usable for update of a single column. Or should you just use
JPQL update and possibly remove all dogs from the second-level cache? How ORM is that?

Why JPA doesn't provide better fetch control for finds? I want to work with this `Dog` object now,
I'm not interested in its relations, just wrap those FK values into otherwise empty entity objects
(like references) and let me do my stuff! How I wished I could just map raw FK value instead of
relation... actually, you can, but while you are able to load such related object explicitly
(find by id), you can't join on that relationship. Or can you?

There are little to no examples of this, because *JPA 2.0* could not do that. All the joins were
implicit and without the mapping (`@One/ManyToOne/Many`) it simply dit not work. I actually
wandered "why can't I join on any value?!" for long time. And then, with *JPA 2.1* out in a wild for
about a year, I discovered that I indeed **can** `JOIN` on any condition -- and that way I can join
with raw FK. This ultimately led me to some extreme measures and I got rid of *to-one* mappings
and never looked back.

So that is what the chapter [Moving away from *to-one* relationships](#ch-away-from-to-one) is
about. Other points are much less radical compared to this one. Long before I learnt that being
explicit and less lazy is definitely better and we will talk about it in other sections.


## How does this affect my domain model?

I stated that this book will not be about architecture, but this is the part where we have to
tackle it a bit. If we talk about [domain model](https://en.wikipedia.org/wiki/Domain_model), we
probably also talk about [domain driven design](https://en.wikipedia.org/wiki/Domain-driven_design)
(DDD) best described in [[DDD](#bib-ddd)]. I can't claim experience with DDD because I never saw it
in practice, but it must work for some, reportedly, especially for complex business domains with
lots of rules, etc. Reading [[PoEAA](#bib-poeaa)] it is obvious that there's a lot of synergy
between DDD and ORM. One may even ask whether to use ORM without DDD at all. And I can't answer
that, sorry.

[[PoEAA](#bib-poeaa)] recommends other patterns for simpler domain problems (*Transaction Script*,
*Table Module*) with related data source patterns (*Table Data Gateway*, *Row Data Gateway*
or *Active Mapper*). There are some newer architectural solutions as well, like *Command Query
Responsibility Segregation* ([CQRS](http://martinfowler.com/bliki/CQRS.html)) or *Data, context
and interaction* ([DCI](https://en.wikipedia.org/wiki/Data,_context_and_interaction)), both of them
usable with object-oriented languages, but not necessarily for every problem.

Back to domain, though. One anti-pattern often mentioned in relation to ORM/JPA is called
[Anemic domain model](http://www.martinfowler.com/bliki/AnemicDomainModel.html). Let's quote
master Martin Fowler a bit again:

{icon=quote-right}
G> In essence the problem with anemic domain models is that they incur all of the costs of a domain
G> model, without yielding any of the benefits. The primary cost is the awkwardness of mapping to
G> a database, which typically results in a whole layer of O/R mapping. This is worthwhile iff you
G> use the powerful OO techniques to organize complex logic. By pulling all the behavior out into
G> services, however, you essentially end up with Transaction Scripts, and thus lose the advantages
G> that the domain model can bring. As I discussed in P of EAA, Domain Models aren't always the
G> best tool.

I'm not able to slip out of this topic and make object purists happy, but there are many other
styles of programming and the question (far beyond the scope of this book) is whether being purely
OO is the most important thing after all. In most projects I treated my entities like java beans
with just a little low-level logic to it -- so it was mostly this "anemic domain model" song. But
entity objects can be perfect [data transfer objects](https://en.wikipedia.org/wiki/Data_transfer_object)
(DTOs) in many situations. It is still far more advanced compared to amorphous rows of a
`ResultSet`. We have dumb model, but we can utilize it in a domain if we need to.

I even contemplated something like "domain over entity model" solution where entity is as dumb
as possible (it still has responsibility for me, it maps to a database table) and I can wrap it
with whatever logic I want in a domain object. This even allows me to reverse some dependencies
if I wish so -- for instance, in a database my order items point to the order using a foreign key,
but in my higher model it can be the other way around, invoice can aggregate items that may not
even know about an order.

In any case, whatever we do, we can hardly get rid of all the notions of a particular data store
we use, because any such "total abstraction" must lead to some mismatch -- and that typically
leads to complexity and often significant performance penalty as well. The way I go with this
book is trying to get as much benefit from using the JPA without incurring too much cost. Maybe
I'm not going for the best approach, but I'm trying to avoid the biggest pain points while
accepting that I have SQL somewhere down there.

One thing I respect on Fowler et al. is that they try to balance costs/benefits and they neither
push ORM always forward nor do they criticize it all the time without offering real alternatives
for the complex cases. However, many other smart and experienced people dislike ORM. Listening to
"pure haters" does not bring much to a discussion, but some cases are well-argued, offering options
and you can sense the deep understanding of the topic. Which naturally leads us to the next section.


## Love and hate for ORM

As I said already, ORM is typically seen as a good fit with domain-driven design (DDD). But
ORM happened to become extremely popular and people thought it will solve all of their database
access problems without the need to learn SQL. This way obviously failed and hurt ORM back a lot,
too. I say it again, ORM is very difficult, even using well documented ORM (like the JPA standard)
is hard -- there's simply too much in it. We're dealing with complex problem, with a mismatch --
and some kind of mismatch it is. And it's not the basic principle that hurts, we always get burnt
on many, too many, details.

### Vietnam of Computer Science {#vietnam}

One of the best balanced texts that critique ORM, and probably one of the most famous, is quite
old actually. In 2006 Ted Neward wrote an extensive post with a fitting, if provoking, name
[The Vietnam of Computer Science](http://blogs.tedneward.com/post/the-vietnam-of-computer-science/).
If you seriously want to use ORM on any of your projects, you should read this -- unless data
access is not an important part of that project (who are we kidding, right?). You may skip the
history of Vietnam war, but definitely give the technical part a dive it deserves.

ORM wasn't that young anymore in 2006 and various experiences had shown that it easily brought more
problems than benefits - especially if approached with partial knowledge, typically based on
an assumption that "our developers don't need to know SQL". When kind of non-programming architect
recommends this for a project and they are long gone when the trouble appears it's really easy to
recommend it again. It was so easy to generate entities from our [DDL](https://en.wikipedia.org/wiki/Data_definition_language),
wasn't it? Hopefully managers are too high to be an audience for JPA/ORM recommendations,
but technical guys can hurt themselves well enough. The JPA, for instance, is still shiny, it's a
standard after all -- and yeah, it is kinda Java EE-ish, but this is the good new EE, right?

Wrong. Firstly, JPA/ORM is so complex when it comes to details, that using it as a tool for "cheap
developers" who don't need to learn SQL is as silly as it gets. I don't know when learning became
the bad thing in the first place, but some managers think they can save man-months/time/money
without learning. When the things get messy -- and they will -- there is nobody around who really
understands ORM and there is virtually no chance to rewrite data access layer to get rid of it.
Easiest thing to do is to blame ORM.

You may ask: What has changed since 2006? My personal take on the answer would be:

* Nothing essential could have changed, we merely smoothed some rough edges, got a bit more
familiar with already familiar topic and in Java space we standardized the beast (JPA).
* We added more options to query languages to make the gap with SQL smaller. Funny enough, the JPA
actually didn't help here as it lagged couple of years behind capabilities of the leading ORM
solutions.
* Query-by-API (mentioned in the post) is much better nowadays, state of the art technologies like
Querydsl have very rich fluent API that is also very compact (definitely not "much more verbose
than the traditional SQL approach"). Also both type safety and testing practices are much more
developed.

Other than that, virtually all the concerns Ted mentioned are still valid.


### Not much love for ORM

Whatever was written back in 2006, ORMs were on the rise since then. Maybe the absolute numbers of
ORM experts are now higher than then, but I'd bet the ratio of experts among its users plummeted
(though I have no research to support this). ORM/JPA is easily available, Java EE supports it,
Spring supports it, you can use it in Java SE easily, you can even generate CRUD scaffolding for
your application with JPA using some [rapid application development](https://en.wikipedia.org/wiki/Rapid_application_development)
tools. That means a lot of developers are exposed to it. In many cases it seems deceivingly easy
when you start using it.

ORM has a bad reputation with our [DBAs](https://en.wikipedia.org/wiki/Database_administrator) --
and for good reasons too. It takes some effort to make it use reasonable queries, not to mention
that you typically have to break the ORM abstraction to do so. It's good to start with clean,
untangled code as it helps tremendously when you need to optimize some queries later. This,
however, causes many complications. If you explicitly name columns and don't load whole entities
you may get better performance, but it will be unfriendly to the entity cache. The same goes for
bulk updates (e.g. "change this column for all entities where..."). There are the right ways to
do it in the domain model, but learning the right path of OO and domain-driven design is probably
even harder than starting with JPA -- otherwise we'd see many more DDD-based projects around.

We will tackle caching later in this chapter, but I'd say that misunderstandings around ORM caching
are the reason for a lot of performance problems and potentially for data corruption too. This is
when it starts to hurt -- and when you can't get easily out, hate often comes with it. When you
make a mistake with a UI library, you may convince someone to let you rewrite it -- and they can
see the difference. Rewriting data access layer gives seemingly nothing to the client, unless the
data access is really slow, but then the damage done is already quite big anyway.


### But a lot of hate

When you need to bash some technology, ORM is a safe bet. I don't know whether I should even
mention [ORM Is an Offensive Anti-Pattern](http://www.yegor256.com/2014/12/01/orm-offensive-anti-pattern.html)
but as it is now the top result on Google search for ORM, I do it anyway. It wouldn't be fair to
say the author doesn't provide an alternative, but I had read a lot of his other posts (before I
stopped) to see where "SQL-speaking objects" are going to. I cannot see
[single responsibility principle](https://en.wikipedia.org/wiki/Single_responsibility_principle)
in it at all, and while SRP doesn't have to be the single holy grail of OOP, putting everything
into the domain object itself is not a good idea. In different post, domain objects were "enriched"
with all kinds of serialization needed, effectively binding possibly all domain objects to possibly
all technologies you need. I believe OOP has been there already, maybe not before I was born, but
definitely long before I started programming.

There are other flaws with this particular post. Mapping is explained on a very primitive case,
while ORM utilizes unit-of-work for cases where you want to execute multiple updates in a single
transaction, possibly updates on the same object. If every elementary change on the object emits
an SQL and we want to set many properties for the same underlying table in a transaction we get
performance even worse than non-tuned ORM! You can answer with object exposing various methods
to update this and that, which possibly leads to a
[combinatorial explosion](https://en.wikipedia.org/wiki/Combinatorial_explosion). Further, in times
of injection we are shown the most verbose way how to do ORM, the way I haven't seen for years.

"SQL-speaking objects" bring us to a more generic topic of modelling objects in our programs. We
hardly model real-life objects as they act in real life, because in many cases we should not.
Information systems allow changing data about things that normally cannot change, because someone
might have entered the information incorrectly in the first place.

How to model the behavior of a tin can? Should it have `open` method? Even in real life *someone*
opens the *tin* with a *tin opener* -- an interaction of three objects. Why do we insist on objects
storing themselves then? It still may be perfectly valid pattern -- as I said real life is not
always a good answer to our modelling needs -- but it is often overused. While in real-life human
does it, we often have various *helper* objects for behavior, often ending with *-er*. While I see
why this is considered anti-pattern, I personally hate rules like *objects (classes) ending with
-er are evil* -- even more than ORM. (They let me think, though.)

In any case I agree with the point that we should not avoid SQL. If we use ORM we should also know
its QL (JPQL for JPA) and how it maps to SQL. We generally should not avoid of what happens down
the stack, especially when the abstraction is not perfect. ORM, no question about it, is not
a perfect abstraction.

To see a much better case against ORM let's read
[ORM is an anti-pattern](http://seldo.com/weblog/2011/08/11/orm_is_an_antipattern). Here we can
find summary of all the bad things related to ORM, there is hardly anything we can argue about
and if you read Ted Neward's post too, you can easily map the problems from one post to another.
We will go the full circle back to Martin Fowler and his
[ORM Hate](http://martinfowler.com/bliki/OrmHate.html). We simply have to accept ORM as it is
and either avoid it, or use it with its limitations, knowing that the abstraction is not perfect.
If we avoid it, we have to choose relational or object world, but we can hardly have both.

There are, of course, many other problems even if we embrace ORM as it is, after all I named many
in chapter [Questionable parts](#ch-questionable-parts).

### Is tuning-down a way out?

Using less of JPA and relying less on complex auto-magic features is a way I propose. It builds
on the premise that we should use ORM where it helps us, avoid it where it does not and know the
consequences of both cases and their interactions. It may happen that using both ways adds
complexity too, but from my experience it is not the case if you step back with JPA far enough.
JPA has much better mapping of values from DB to objects (even if you use them just as DTOs) than
JDBC. It abstracts concrete SQL flavour away which has its benefits -- and unless this is a real
issue for more than couple of queries you can resolve the rest with either native SQL support in
the JPA, or use JDBC based solution.

Coming to relations, there may be many of them where *to-one* does not pose a problem. In that
case make your life easier and use mapping to objects. If you feel like loosing control over
queries, remap the object with plain foreign key values and add explicit `JOIN ... ON` to your
queries. This all renders JPA as a bit lower-level tool than intended, but still extremely useful.
It still allows you to generate schema from objects if you have control over your RDBMS (sometimes
you don't) or even just document your database with class diagram of entities[^cdd].

[^cdd]: While class diagram does not say exactly the same like E-R diagram I used it successfully
    to communicate design of tables to my DBA who had absolutely no problem to understand it, even
    for cases where many-to-many associative table was implied by a named line. E-R diagram was
    much easier to generate ex-post for documentation purposes.

We still have to keep unit-of-work and caching in check, but both are very useful if used well.
I definitely don't avoid using `EntityManager`, how could I? Caching is a different beast though,
and deserves its own section.


## Caching considerations {#caching-considerations}

[[JPspec](#bib-jpspec)] doesn't say much about caching. It says how to configure it -- starting
with `shared-cache-mode` in your `persistence.xml`. But I'd probably study caching documentation
of a particular provider, because if you don't care at all, you don't even know whether and how
you use the cache.

Without choosing `shared-cache-mode` it is up to the JPA provider and its defaults. This may render
any use of `@Cacheable` annotations useless. Currently, Hibernate typically doesn't cache by
default, while EclipseLink caches everything by default. Being oblivious to the cache (not related
to *cache-oblivious algorithms* at all) is rather dangerous, especially if your application is
not the only one running against the same database. In that case setting `shared-cache-mode`
explicitly to `NONE` is by far the best start. You may revisit your decisions later, but at least
you know what is happening.

T> ### JPA is not the only one caching
T>
T> Caching happens also directly on the database level. You still incur a network round-trip but it
T> does not necessarily load data from a disk (that would be really slow) and you don't have this
T> entity-query duality -- although we don't know how complex the database cache is. In any case,
T> it is used whether we use second-level cache or not and, luckily, it is mostly totally
T> transparent for a programmer or user.

Probably the most important question to answer is: Is your application the sole user of a particular
database? If yes, you may safely use the cache without much thinking (or defaults, which may be no
cache as well). This does not mean that is a good idea. If you start tuning it be prepared for
a walk that may be not that easy.

Still, entity cache returning you entities by ID really quickly, is a great idea in ORM world,
because it makes the problem of eager-loads of to-one relationships much smaller. It doesn't fix
it though as all those entities are part of your current persistence context whether you want them
or not. We already mentioned that units of work bigger than necessary are not for free.

T> ### When JPA is not the only one caching
T>
T> TODO:
T> anti-patterns: caching returned JPA entities with JSR-107/Spring (first time they are managed, next time they are not)

* explicit application caching
* entity cache memory considerations


D> ### Let database to cache it all?
D>
D> TODO: As said DB has its caches too. If we distribute and pay the price for remote access
D> maybe we can drop JPA caches altogether?

## When to tune down and when not?

TODO:...