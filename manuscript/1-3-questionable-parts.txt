# Questionable parts {#ch-questionable-parts}

The JPA, as any ORM, is not without its drawbacks. Firstly, it is complex, much deeper than
developers realize when they approach it. Secondly, it is not a perfect abstraction. The more you
want to play it that way (as a perfect abstraction) the worse it probably gets in marginal cases.
And the margin is not very thin. You may solve 80% cases easily, but there are still 20% of hard
cases where you go around your ORM, write native SQL, etc. If you try to avoid it you'll probably
suffer more than if you accepted it.

You can't just stay on the JPA level, even for cases where ORM works well for you. There are
these details you should know about a provider you use. For instance, let's say you have an entity
with auto-generated identifier based on IDENTITY (or AUTO_INCREMENT) column. You call `persist`
on it and later you want to use its ID somewhere. And it doesn't work, because you're using
EclipseLink and you didn't call `flush` to actually execute that INSERT. Without it the provider
cannot know what value for ID it should use. Maybe your usage of ID value was not the right
*ORM way*, maybe you should have use the whole entity somewhere, but the point is that if you do
the same with Hibernate, it would work. You simply cannot assume that the ID is set.[^demoid]

[^demoid]: You can see this demonstrated in `examples/basic` if you run: `mvn test-compile
exec:java -Dexec.mainClass="tests.GeneratedIdSettingDemo"`

## Lazy on basic and *to-one* fields {#lazy-problems}

TODO

## Generated updates

* unit-of-work works only with whole entities, it does not emit partial updates

## Big unit of work

* unit-of-work "caching" and tracking a lot of data that are to be viewed (can be fixed with
readonly transactions, nice example of being explicit)

## Unit of work vs queries

TODO

## Second-level cache vs queries {#cache-vs-queries}

While persistence context (`EntityManager` or session) is sometimes considered a cache too, it
is merely a part of the unit-of-work pattern. The real cache sits underneath and is shared on the
level of the `EntityManagerFactory` -- or even between more of them across various JVMs in case
of distributed caches. This is called the *second-level cache*.[^slc] It is used to enhance
performance, typically by avoiding round-trips to the database. But caching has consequences.

[^slc]: Second-level cache is most popular term, used also in [[JPspec](#bib-jpspec)]. It appears
in [[PJPA2](#bib-projpa2)] too, but *in-memory cache* is used more often there.

Caching should be transparent, but just turning it on is a kind of *premature optimization* which
-- in virtually all cases -- ends up being wrong. Any auto-magic can only go so far, and any
caching leads to potential inconsistencies. I believe most JPA users don't understand how the cache
is structured (I'm talking from my own experience too, after all). This depends on a concrete ORM,
but typically there is an *entity cache* and a *query cache*.

Entity cache helps with performance of `EntityManager.find`, or generally with loading by entity's
`@Id` attribute. But this will not help you if you accidentally obfuscate what you want with a
query, that would otherwise return the same. The provider has no way to know what entity (with what
ID) will be loaded just looking at arbitrary where conditions. This is what query cache is for.
Bulk update and deletes using JPQL go around either of these caches and the safest way how to
avoid inconsistent data is to evict all entities of the modified type from the caches. This is
often performed by the ORM provider automatically (again, check documentation and settings).

If you only work with whole entities the whole time *and* nothing else accesses the database you
can be pretty sure you always get the right result from the entity cache. You may wonder how this
cache behaves in concurrent environment (like any EE/Spring application inherently is). If you
imagine it as a `Map`, even with synchronized access, you may feel the horror of getting the same
entity instance (`Dog` with the same ID) for two concurrent persistence contexts (like concurrent
HTTP requests) that subsequently modify various fields on the shared instance. Luckily, ORMs
provide each thread with its own copy of the entity. Internally they typically keep entities in
the cache in some "dehydrated" form.[^ecacheorm]

[^ecacheorm]: Tested with Hibernate and EclipseLink.

We will discuss caching again when we talk about [tuning it down](#caching-considerations).


## You can't escape SQL and relation model

TODO: Example: Paging with to-many fetching

Other problems:
* monitoring of SQL from JPA application is difficult (it's kinda "elsewhere") and the
interaction with the SQL itself has a lot of overhead as well (but this is complex topic anyway,
JDBC proxy driver is possibility, but how to connect to the business logic or place where it
happens?)
* updates of all columns when just one was changed (not inherent JPA problem, but happens)
* bugs cross-fire, different providers have different bugs, but all are show-stoppers for
a project

## And there is more

This list of potential surprises is far from complete and we will continue in similar tone at
the beginning of the following part.