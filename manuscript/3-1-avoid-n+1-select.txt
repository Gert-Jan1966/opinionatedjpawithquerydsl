# Avoid N+1 select {#ch-avoid-n-plus-1}

While performance tuning is not the main goal of this book we should follow some elementary
performance common sense. If we can avoid an unnecessary query we should do so. With ORM/JPA
we can generate a lot of needless queries without even realizing. In this chapter we will cover
the most pronounced problem called *N+1 select*.

{icon=book}
G> ### SQL Performance Explained
G>
G> I can highly recommend this incredible book ([[SQLPE](#bib-sqlpe)]) which explains indexes,
G> joins, execution plans and many other aspects of queries (including data modification) in just
G> under 200 pages. This not only is a true gem in this area, it can be also obtained as PDF from
G> [its site](http://sql-performance-explained.com) for 10 Eur or so. It mentions N+1 problem
G> as well.


## Anatomy of N+1 select

I'd prefer to call this problem 1+N because it mostly starts with one query that returns N rows
and induces N additional queries. While addition is commutative -- hence 1+N is the same like N+1
-- I'll stick to *N+1* as usually used in literature. The typical scenarios when the N+1 problem
appears are:

* Query for N entities that have eager *to-one* relationship -- or more of them -- and the provider
is not smart enough to use joins.
* Query for N entities that have eager *to-many* relationship and the provider is either not smart
enough to use the join (again) or it is not possible to use it for other reasons like pagination.
We will cover paginating of entities with *to-many* [later in this chapter](#to-many-paginating).
* Query for N entities later with lazy relationship that is triggered later, e.g. in the view as
usual with open-session-in-view (OSIV) pattern.

There are probably more scenarios, but these are the most typical ones. First let's look at the
eager examples.


### Eager *to-one* without joins

If you recall our [simple example with `@ManyToOne`](#many-to-one-simple-example) from the chapter
[Troubles with *to-one* relationships](#ch-to-one-troubles) you know that *to-one* relationships
may trigger additional fetching. With EclipseLink, for instance, when your query returns three dogs
there will be three additional `em.find` calls to get their breeds by ID. These may result in
DB queries or they can be found in the cache -- depends on your setting -- and this all must be
taken into consideration. Hibernate, on the other hand, produces the join for breeds right away.

In any case there may be more *to-one* relationships that may trigger additional fetches, unless
these are marked as lazy and respected by your JPA provider (not guaranteed). Let's reuse the data
[from the Querydsl chapter](#func-and-oper) -- here they are again:

{title="Content of **Breed** table", width="narrow"}
| id | name |
|----|------|
| 1 | collie |
| 2 | german shepherd |
| 3 | retriever |

{title="Content of **Dog** table (id is not important)", width="narrow"}
| name | age | breed_id |
|------|-----|----------|
| Lassie | 7 | 1 (collie) |
| Rex | 6 | 2 (german shepherd) |
| Ben | 4 | 2 (german shepherd) |
| Mixer | 3 | `NULL` (unknown breed) |

Now let's list all the dogs like this:

~~~
List<Dog> dogs = new JPAQuery<>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .fetch();
~~~

We get four dogs of two different breeds (one dog is "breed-less") but what happened on the SQL
level? EclipseLink does this:

~~~
SELECT ID, AGE, breed_id, NAME FROM DOG
SELECT ID, NAME FROM BREED WHERE (ID = ?)
SELECT ID, NAME FROM BREED WHERE (ID = ?)
~~~

And that virtually classifies as N+1 problem, although the N may be lower than the count of
selected rows thanks to the persistence context. Hibernate makes more sense here:

~~~
select dog0_.id as id1_1_, dog0_.age as age2_1_,
  dog0_.breed_id as breed_id3_1_, dog0_.name as name4_1_ from Dog dog0_
~~~

Of course, we can write query with the same join in the first place. It doesn't take advantage
of any cached results but at least we say exactly what we want. With any further *to-one*
relationships you may want to use lazy fetch for the data you don't need (and you know you can
rely on `LAZY`) or try some other technique described in [Troubles with *to-one*
relationships](#ch-to-one-troubles) (entity views come to mind, but projections are even better).


### Eager *to-many* relationships

TODO: where does this make sense?


### Lazy relationships triggered later

TODO


## Paginating with *to-many* {#to-many-paginating}

I mentioned previously that we [can't escape SQL](#cant-escape-sql) underneath.

TODO bigger example, some table picture, then solution

Possible pure SQL solution where we only paginate over the table we need to -- but this requires
subquery in from:

~~~
-- situation
select * from owner;
ID  	NAME  
1	Adam
2	Charlie
3	Joe
4	Mike
(4 rows, 1 ms)

select * from dog where owner_id is not null;
ID  	NAME  	BREED  	OWNER_ID  
3	Alan	null	1
4	Beastie	null	1
5	Cessna	null	1
6	Rex	null	3
7	Lessie	null	4
8	Dunco	null	4
(6 rows, 0 ms)

-- good
select * from (select * from owner limit 2 offset 2) o left join dog d on o.id=d.owner_id ;
ID  	NAME  	ID  	NAME  	BREED  	OWNER_ID  
3	Joe	6	Rex	null	3
4	Mike	7	Lessie	null	4
4	Mike	8	Dunco	null	4
(3 rows, 0 ms)

-- wrong
select * from owner o left join dog d on o.id=d.owner_id limit 2 offset 2;
ID  	NAME  	ID  	NAME  	BREED  	OWNER_ID  
1	Adam	5	Cessna	null	1
2	Charlie	null	null	null	null
~~~

TODO: what happens with relationships marked as EAGER?