# Avoid N+1 select {#ch-avoid-n-plus-1}

While performance tuning is not the main goal of this book we should follow some elementary
performance common sense. If we can avoid an unnecessary query we should do so. With ORM/JPA
we can generate a lot of needless queries without even realizing. In this chapter we will cover
the most pronounced problem called *N+1 select*.

{icon=book}
G> ### SQL Performance Explained
G>
G> I can highly recommend this incredible book ([[SQLPE](#bib-sqlpe)]) which explains indexes,
G> joins, execution plans and many other aspects of queries (including data modification) in just
G> under 200 pages. This not only is a true gem in this area, it can be also obtained as PDF from
G> [its site](http://sql-performance-explained.com) for 10 Eur or so. It mentions N+1 problem
G> as well.


## Anatomy of N+1 select

I'd prefer to call this problem 1+N because it mostly starts with one query that returns N rows
and induces N additional queries. While addition is commutative -- hence 1+N is the same like N+1
-- I'll stick to *N+1* as usually used in literature. The typical scenarios when the N+1 problem
appears are:

* Query for N entities that have eager *to-one* relationship -- or more of them -- and the provider
is not smart enough to use joins.
* Query for N entities that have eager *to-many* relationship and the provider is either not smart
enough to use the join (again) or it is not possible to use it for other reasons like pagination.
We will cover paginating of entities with *to-many* [later in this chapter](#to-many-paginating).
* Query for N entities later with lazy relationship that is triggered later, e.g. in the view as
usual with open-session-in-view (OSIV) pattern.

There are probably more scenarios, but these are the most typical ones. First let's look at the
eager examples.


### Eager *to-one* without joins

TODO


## Paginating with *to-many* {#to-many-paginating}

I mentioned previously that we [can't escape SQL](#cant-escape-sql) underneath.

TODO bigger example, some table picture, then solution

Possible pure SQL solution where we only paginate over the table we need to -- but this requires
subquery in from:

~~~
-- situation
select * from owner;
ID  	NAME  
1	Adam
2	Charlie
3	Joe
4	Mike
(4 rows, 1 ms)

select * from dog where owner_id is not null;
ID  	NAME  	BREED  	OWNER_ID  
3	Alan	null	1
4	Beastie	null	1
5	Cessna	null	1
6	Rex	null	3
7	Lessie	null	4
8	Dunco	null	4
(6 rows, 0 ms)

-- good
select * from (select * from owner limit 2 offset 2) o left join dog d on o.id=d.owner_id ;
ID  	NAME  	ID  	NAME  	BREED  	OWNER_ID  
3	Joe	6	Rex	null	3
4	Mike	7	Lessie	null	4
4	Mike	8	Dunco	null	4
(3 rows, 0 ms)

-- wrong
select * from owner o left join dog d on o.id=d.owner_id limit 2 offset 2;
ID  	NAME  	ID  	NAME  	BREED  	OWNER_ID  
1	Adam	5	Cessna	null	1
2	Charlie	null	null	null	null
~~~

