# Advanced Querydsl {#ch-advanced-querydsl}

## Tricky predicate parts

TODO: BooleanBuilder, and/or and other prioritized operations serialization, ...


## Using FUNCTION template

TODO


## Detached queries {#querydsl-detached-queries}

While we can create all the queries in methods provided with `EntityManager` parameter, but
sometimes it feels more natural to put queries into a constant a reuse them later. This is
possible using so called "detached queries" -- simply create a query without entity manager
and later clone it with entity manager provided:

{title="Querydsl, detached query", lang=java}
~~~
private static QDog DOG_ALIAS = new QDog("d1");
private static Param<String> DOG_NAME_PREFIX =
  new Param<String>(String.class);
private static JPAQuery<Dog> DOG_QUERY = new JPAQuery<Dog>()
  .select(DOG_ALIAS)
  .from(DOG_ALIAS)
  .where(DOG_ALIAS.name.startsWith(DOG_NAME_PREFIX));

//... and somewhere in a method
List<Dog> dogs = DOG_QUERY.clone(em)
  .set(DOG_NAME_PREFIX, "Re")
  .fetch();
~~~

The benefit is questionable though. You need to name the query well enough so it expresses what
it does while seeing the query sometimes says it better. You have to walk the distance to introduce
parameters explicitly -- you don't want it constant. And I doubt there is any performance benefit
as we clone the query. I'm sure there are legitimate cases when to use
this feature, but I personally use it only in query objects wrapping complicated query where I have
a lot of aliases around already -- and even then mostly without the where part which I rather add
dynamically later.

%% TODO: revisit clone and other methods in multi-threaded environments, with 3.x we must use
%% synchronized for these cases


## Working with dates and `java.time` API

TODO

This is how to convert return of the `DateTimeExpression` function to specific date/time type:
```
Tuple notificationWithState = queryFrom($)
  .innerJoin(n).on(n.id.eq($.notificationId))
  .where($.mailStatus.eq(GuiUserNotificationSendStatus.TO_SEND)
    .and(n.validFrom.lt(DateTimeExpression.currentTimestamp(LocalDateTime.class))))
  .orderBy($.id.desc())
  .singleResult($, n);
```

How to coerce with `java.util` types? How to mix `LocalDate` and `LocalDateTime`?



## Note about Querydsl 3 versus 4

I've used major versions 2 and 3 in my projects and started to use version 4 only when I started
to write this book. After initial investigation I realized that I'll hardly switch from version 3
to version 4 in any reasonably sized project easily. Other thing is whether I even want. I don't
want to let version 4 down, it does a lot to get the DSL closer to SQL semantics -- but that's
the question: Is it really necessary?

Let's compare a query from version 4 with the same query from version 3 -- let's start with 4:

{title="Querydsl version 4 query", lang=java}
~~~
List<Dog> dogs = new JPAQuery<Dog>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .where(QDog.dog.name.like("Re%"))
  .fetch();
~~~

Next example shows the same in Querydsl version 3:

{title="Querydsl version 3 query", lang=java}
~~~
List<Dog> dogs = new JPAQuery(em)
  .from(QDog.dog)
  .where(QDog.dog.name.like("Re%"))
  .list(QDog.dog);
~~~

Personally I like the latter more even though the first one is more SQL-like notation. Version 3
is one line shorter -- that purely technical `fetch()` call is pure noise. Further that `fetch()`
was used in version 3 to declare fetching of the joined entity, in version 4 you have to use
`fetchAll()` for that. This means that `fetch*()` methods are not part of one family -- that's
far from ideal from API/DSL point of view.

Another thing is that version 3 API was actually really fluent. I didn't have to parametrize
`JPAQuery` constructor -- in version 4 you have to otherwise `where(...)` does not return anything
you can call `fetch()` on. In version 3 you went on and on, maybe there was a bit less compile-time
safety, but I never encountered this as a real problem. Version 3 worked perfectly with IDE,
version 4 is rather annoying with that parametrized constructor without giving me, the programmer,
any additional benefit. (I don't claim to know all about these API/DSL changes, though.)

As the fluency goes most programmers in our team agreed to prefer finish with the
`list(expressions...)` call as the last call clearly says what gets returned. With SQL-like
approach you do this first, then add various `JOIN`s -- but this all fights typical Java-like
programming mindset. For me personally version 3 hit the sweet spot perfectly, not fighting
Java syntax (I feel a bit of a struggle between Querydsl 4 and Java) and giving me very
SQL-like style of queries.

We can also question what changes more. Sometimes we change the list of expressions, which means
we have to construct the whole query again and the most moving part -- the list of resulting
expressions -- go somewhere in the middle (actually right at the start!). I cannot have my query
template with `FROM` and `JOIN`s ready anymore. All I had to do before was to clone it (so we don't
change the template), add where parts based on some filter and declare what expressions we want
as results, based on well-known available aliases, columns, etc.

Sure you have to have those aliases thought through before anyway, so it's not such a big deal to
create all the queries dynamically and add `JOIN`s after you "use them" in the `SELECT` part,
because the aliases are the common ground and probably available as some constants. But there is
another good scenario for pre-created template query -- you can use it as... well, we said it
already, as a template. This way you can ask its metadata and do some preparation based on this.
We use this for our filter framework where the guys from UI know exactly what kind of aliases we
offer, because we crate a `Map<String, SimpleExpression<?>>` to get to the paths representing the
alias by its name very quickly. We can still do this with Querydsl 4. We create one query selecting
the entity used in the `FROM` clause (makes sense) and extract the map of aliases on this one,
discarding this "probe query" afterwards. Not a big deal, but still supports the idea that after
the `WHERE` clause it is the `SELECT` part that is most flexible and using it right at the start
of the "sentence" may sound natural, but not programmatically right.

D> The same applies for SQL itself. In its time it was probably great, but imagine nowadays IDEs
D> that can help you with the `SELECT` part of the query. What will you do? You'll write `SELECT *`
D> and finish the rest (froms, joins, wheres) and return to that `*` expecting that IDE will give
D> you hints based on actual tables/aliases used. This "backward-ish" flow opens space for that
D> question: Is the original order of clauses really the best one? I believe Querydsl 3 was ahead
D> and shouldn't go back to SQL.