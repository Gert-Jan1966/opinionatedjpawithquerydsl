# Advanced Querydsl {#ch-advanced-querydsl}

## Tricky predicate parts

TODO: BooleanBuilder, and/or and other prioritized operations serialization, ...


## Using FUNCTION template

TODO


## Detached queries {#querydsl-detached-queries}

While we can create all the queries in methods provided with `EntityManager` parameter, but
sometimes it feels more natural to put queries into a constant a reuse them later. This is
possible using so called "detached queries" -- simply create a query without entity manager
and later clone it with entity manager provided:

{title="Querydsl, detached query", lang=java}
~~~
private static QDog DOG_ALIAS = new QDog("d1");
private static Param<String> DOG_NAME_PREFIX =
  new Param<String>(String.class);
private static JPAQuery<Dog> DOG_QUERY = new JPAQuery<Dog>()
  .select(DOG_ALIAS)
  .from(DOG_ALIAS)
  .where(DOG_ALIAS.name.startsWith(DOG_NAME_PREFIX));

//... and somewhere in a method
List<Dog> dogs = DOG_QUERY.clone(em)
  .set(DOG_NAME_PREFIX, "Re")
  .fetch();
~~~

The benefit is questionable though. You need to name the query well enough so it expresses what
it does while seeing the query sometimes says it better. You have to walk the distance to introduce
parameters explicitly -- you don't want it constant. And I doubt there is any performance benefit
as we clone the query. I'm sure there are legitimate cases when to use
this feature, but I personally use it only in query objects wrapping complicated query where I have
a lot of aliases around already -- and even then mostly without the where part which I rather add
dynamically later.

%% TODO: revisit clone and other methods in multi-threaded environments, with 3.x we must use
%% synchronized for these cases

## Note about Querydsl 3 versus 4

I've used major versions 2 and 3 in my projects and started to use version 4 only when I started
writing this book. After initial investigation I realized that I'll hardly switch from version 3
to version 4 in any reasonably sized project easily. Other thing is whether I even want. I don't
want to let version 4 down, it does a lot to get the DSL closer to SQL semantics -- but that's
the question: Is it really necessary?

Let's compare a query from version 4 with the same query from version 3 -- let's start with 4:

{title="Querydsl version 4 query", lang=java}
~~~
List<Dog> dogs = new JPAQuery<Dog>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .where(QDog.dog.name.like("Re%"))
  .fetch();
~~~

Next example shows the same in Querydsl version 3:

{title="Querydsl version 3 query", lang=java}
~~~
List<Dog> dogs = new JPAQuery(em)
  .from(QDog.dog)
  .where(QDog.dog.name.like("Re%"))
  .list(QDog.dog);
~~~

Personally I like the latter better even though the first one is more SQL-like notation. Version 3
is one line shorter -- that purely technical `fetch()` call is pure noise. Further that `fetch()`
was used in version 3 to declare fetching of the joined entity, in version 4 you have to use
`fetchAll()` for that. This means that `fetch*()` methods are not part of one family -- that's
far from ideal from API/DSL point of view.

Another thing is that version 3 API was actually really fluent. I didn't have to parametrize
`JPAQuery` constructor -- in version 4 you have to otherwise `where(...)` does not return anything
you can call `fetch()` on. In version 3 you went on and on, maybe there was a bit less compile-time
safety, but I never encountered this as a real problem. Version 3 worked perfectly with IDE,
version 4 is rather annoying with that parametrized constructor without giving me, the programmer,
any additional benefit. (I don't claim to know all about these API/DSL changes, though.)

As the fluency goes most programmers in our team agreed to like final `list(expressions...)` call
so much more as the last call clearly says what gets returned. With SQL-like approach you do this
first, then add various `JOIN`s -- but this all fights typical Java-like programming mindset. For
me personally version 3 hit the sweet spot perfectly, not fighting Java syntax (I feel a bit of a
struggle between Querydsl 4 and Java) and giving me very SQL-like style of queries.