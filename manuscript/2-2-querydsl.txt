# No further step without Querydsl {#ch-querydls}

To put it simply -- [Querydsl](www.querydsl.com) is a library that -- from programmer's
perspective -- works like a more expressive and readable version of *Java Persistence Criteria
API*. Internally it first generates JPQL and the rest from there is handled by the JPA provider.
Querydsl can actually talk to many more back-ends: SQL, Hibernate directly, ... and many
more, but we will focus on Querydsl over JPA here. To use it goes in these steps:

* declare the dependency for Querydsl library and to its annotation processor,
* add a step in your build to generate metamodel classes,
* and write queries happily in sort of criteria-like way.

But Criteria API also lets you use generated metamodel, so what's the deal? Why would I introduce
non-standard third-party library when it does not provide any additional advantage? If you even
hate this idea, then you probably can stop reading this book -- or you can translate all my
Querydsl code into JPQL or Criteria yourself, which is perfectly doable, of course! Querydsl does
not disrupt the stack under it, it is "just" slapped over the JPA to make it more convenient.

Querydsl brings in a [domain-specific language](https://en.wikipedia.org/wiki/Domain-specific_language)
(or DSL) in the form of its fluent API. It happens to be so-called internal DSL because it's still
embedded in Java, it's not different language per se. This fluent API is much more readable and
convenient than Criteria API which has couple of advantages.

DSL is a language of some specific domain -- in this case it's a query language very close to JPQL
or SQL. It builds on a generated metamodel a lot. API of this metamodel is well-though and takes
type-safety to a higher level compared with Criteria API. This not only gives us compile-time
checks for our queries, but also offers even better auto-completion in IDEs.


## Simple example with Querydsl

Let's be concrete now -- but also very simple. We have a class `Dog`, each dog has a `name`
and we will query by this `name`. Assuming we got hold of `EntityManager` (variable `em`) the code
goes like this:

{title="Querydsl simple example", lang=java}
~~~
List<Dog> dogs = new JPAQuery<Dog>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .where(QDog.dog.name.like("Re%"))
//.where(QDog.dog.name.startsWith("Re")) // alternative
  .fetch();
~~~

Both `where` alternatives produce the same result in this case, but `startsWith` may communicate
the intention better, unless you go for `like("%any%")` in which case `contains` would be better.
If you are provided input values for `like`, leave it. If you can tell from the logic that more
specific name for the operation is better, go for it.

This is a very subtle thing, but we can see that this DSL contains variations that can communicate
our intention more clearly. Criteria API sticks to `like` only, because that is its internal model.
Other thing is how beautifully the whole query flows. In version 4.x the fluent API got even closer
to JPQL/SQL semantics, it starts with `select` (what) and ends with `fetch` which is a mere
signal to deliver the results. As with any other fluent API, you need a terminal operation.
In previous versions you would have no `select` because it was included in a terminal operation,
e.g. `list(QDog.dog)`. Newer version is one line longer, but closer to the target domain
of query languages.

D> And yes, I wrap the code like this even in IDE where I could afford 160 characters or more.
D> That, however, is completely different topic and there are people that can explain it [much
D> better](http://www.infoq.com/presentations/7-ineffective-coding-habits).
D> The whole linked presentation is good (and fun!), but at least watch the part from 17m25s.


## Comparison with Criteria API

Both Querydsl and Criteria API are natural fit for dynamic query creation. Doing this with JPQL
is rather painful. Imagine a search form with separate fields for a person
entity, so you can search by name, address, date of birth from--to, etc. We don't want to add
the search condition when the respective input field is empty. If you have done this before
with any form of query string concatenation then you probably know the pain. In extreme cases
of plain JDBC with prepared statement you even have to write all the `if`s twice -- first to add
`where` condition (or `and` for any next one) and second to set parameters. Technically you can
embed the parameter values into the query, but let's help the infamous
[injection](https://en.wikipedia.org/wiki/SQL_injection) vulnerability get off the top of the
[OWASP Top 10 list](https://www.owasp.org/index.php/Top_10_2013-Top_10).

T> If you ever need to construct JDBC statements again -- and there are cases when JPA is not
T> enough, like streaming a really long list of results -- you definitely want to use something like Spring's
T> [`JdbcTemplate`](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/jdbc.html#jdbc-JdbcTemplate).
T> This still leaves putting the query together to you, but allows you to add each parameter
T> value at the time when you add the where part. And also takes away many low-level JDBC concerns.
T>
T> BTW: Do you remember *JPA 1.0*? It didn't have any Criteria API!

Let's see how query for our dogs looks like with Criteria API -- again starting from `em`:

{title="Criteria API simple example", lang=java}
~~~
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Dog> query = cb.createQuery(Dog.class);
Root<Dog> dog = query.from(Dog.class);
query.select(dog)
  // this is the only place where we can use metamodel in this example
  .where(cb.like(dog.get(Dog_.name), "Re%"));
  // without metamodel it would be:
//.where(cb.like(dog.<String>get("name"), "Re%"));
List<Dog> dogs = em.createQuery(query)
  .getResultList();
~~~

Let's observe now:

* First you need to get `CriteriaBuilder` from existing `em`. You might "cache" this into
a field but it may not play well with EE component model, so I'd rather get it before using.
This should not be heavy operation, in most cases entity manager holds this builder already
and merely gives it to you (hence `get` and not `new` or `create`).
* Then you create an instance of `CriteriaQuery`.
* From this you need to get a `Root` object representing content of a `from` clause.
* Then you use the `query` in a nearly-fluent fashion. Version with metamodel is presented
with alternative without it in the comment.
* Finally, you use `em` again to get a `TypedQuery` based on the `CriteriaQuery` and we ask it
for results.

D> Creators of JPA decided not to go with fluent API and it shows. If you read this for a while
D> you'll get the meaning, especially when you're used to it, but our mind needs bigger mental
D> shift to get the meaning compared with the Querydsl version. Clearly, signal-to-noise ratio
D> is much lower too.

While in case of Criteria API you don't need to generate metamodel from the entity classes,
in Querydsl this is not optional. But using metamodel in Criteria API is advantageous anyway
so the need to generate the metamodel for Querydsl using annotation processor can hardly be
considered a drawback. It can be easily integrated with Maven or other build as demonstrated
in the [companion sources](https://github.com/virgo47/opinionatedjpawithquerydsl/blob/master/examples/basic/pom.xml)
to this book or [documented](http://www.querydsl.com/static/querydsl/4.0.7/reference/html/ch02.html#d0e127)
on Querydsl site.

For another comparison of Querydsl and Criteria API, you can also check the
[original blog post](http://blog.mysema.com/2010/04/querydsl-as-alternative-to-jpa-2.html)
from 2010. Querydsl was much younger then (version 1.x) but the difference was striking already.


## Comparison with JPQL

Comparing Querydsl with Criteria API was rather easy as they are in the same ballpark. Querydsl,
however, with its fluency can be compared to JPQL as well. After all JPQL is non-Java DSL,
even though it typically is embedded in Java code. Let's see JPQL in action first to finish
our side-by-side comparisons:

{title="JPQL simple example", lang=java}
~~~
List<Dog> dogs = em.createQuery(
  "select d from Dog d where d.name like :name", Dog.class)
  .setParameter("name", "Re%")
  .getResultList();
~~~

This is it! Straight to the point, and you can even call it fluent! Probably the best we can do
with Querydsl is adding one line to introduce shorter "alias" like this:

{title="Querydsl simple example with alias", lang=java}
~~~
QDog d = new QDog("d1");
List<Dog> dogs = new JPAQuery<Dog>(em)
  .select(d)
  .from(d)
  .where(d.name.startsWith("Re"))
  .fetch();
~~~

Using aliases is very handy especially for longer and/or more complicated queries. We could
use `QDog.dog` as the value, or here I introduced new query variable and named it `d1`. This
name will appear in generated JPQL that looks a little bit different from the JPQL in example
above:

~~~
select d1 from Dog d1 where d1.name like ?1 escape '!'
~~~

There is a subtle difference in how Querydsl generates `like` clause -- which, by the way, is fully
customizable using Querydsl templates. But you can see that alias appears in JPQL, although neither
EclipseLink nor Hibernate bother to translate it to the generated SQL for your convenience.

Now, if we compare both code snippets above (alias creation included) we get a surprising result --
there are more characters in the JPQL version! Although it's just a nit-picking (line/char up or
down), it's clear that Querydsl can express JPQL extremely well (especially in 4.x version)
and at the same time it allows for easy dynamic query creation.

If you're familiar with JPQL more than me (which is not that hard, after all) you may ask about
named queries. Here I admit right away, that Querydsl necessarily introduces overhead (see
[cons](#querydsl-cons) section), but when it comes to query reuse from programmer's perspective,
there is an answer called...


## Detached queries

While we can create all the queries in methods provided with `EntityManager` parameter, but
sometimes it feels more natural to put queries into a constant a reuse them later. This is
possible using so called "detached queries" -- simply create a query without entity manager
and later clone it with entity manager provided:

{title="Querydsl, detached query", lang=java}
~~~
private static QDog DOG_ALIAS = new QDog("d1");
private static Param<String> DOG_NAME_PREFIX = new Param<String>(String.class);
private static JPAQuery<Dog> DOG_QUERY = new JPAQuery<Dog>()
  .select(DOG_ALIAS)
  .from(DOG_ALIAS)
  .where(DOG_ALIAS.name.startsWith(DOG_NAME_PREFIX));

//... and somewhere in a method
List<Dog> dogs = DOG_QUERY.clone(em)
  .set(DOG_NAME_PREFIX, "Re")
  .fetch();
~~~

The benefit is questionable though. You need to name the query well enough so it expresses what
it does while seeing the query sometimes says it better. You have to walk the distance to introduce
parameters explicitly (you wouldn't like it constant). And I doubt there is any performance benefit
as the clone (I guess) clones the query anyway. I'm sure there are legitimate cases when to use
this feature, but I personally use it only in query objects wrapping complicated query where I have
a lot of aliases around anyway -- and even then mostly without the where part which I rather add
dynamically later.


## And the cons? {#querydsl-cons}

Before we move to a couple of advanced topics I'd go over the disadvantages of using Querydsl.
For one, you're definitely adding some overhead. I don't know exactly how big, maybe with the SQL
backend (using JDBC directly) it would be more pronounced because ORM itself is big overhead
anyway. In any case, there is object graph of the query in the memory before it is serialized into
JPQL -- and from there it's on the same baseline like using JPA directly.

This performance factor obviously is not a big deal for many Querydsl users (some of them are
really big names), it mostly does not add too much to the SQL execution itself, but in any case --
if you are interested you have to measure it yourself. Also realize that without Querydsl you
either have to mess with JPQL strings before you have the complete dynamic WHERE part or you should
compare it with Criteria API which does not have to go through JPQL, but also creates some object
graph in the memory (richer or not? depends).

Documentation, while good, is definitely not complete. For instance, detached queries are not
mentioned in their [Query Reference Guide](http://www.querydsl.com/static/querydsl/4.0.7/reference/html_single/)
and there is much more you need to find out yourself. You'll need to find your own best practices,
probably, but it is not that difficult with Querydsl. Based (not only) on my own experience, it
is literally joy to work with Querydsl and explore what it can provide -- for me it worked like
this from day zero. It's also very easy to find responses on the
[stackoverlow](http://stackoverflow.com/questions/tagged/querydsl) or their
[mailing-list](https://groups.google.com/forum/#!forum/querydsl), very often provided directly
by Querydsl developers. This makes any lack of documentation easy to overcome.

Finally, you're adding another dependency to the project, which may be a problem for some. For us
it is well compensated with the code clarity Querydsl gave us.


## Be explicit with aliases

http://stackoverflow.com/questions/6385036/querydsl-generated-classes-not-able-to-access-second-level-elements-for-querying


## Tricky predicate parts

TODO: BooleanBuilder, and/or and other prioritized operations serialization, ...


## Using FUNCTION template

TODO


## More

http://www.slideshare.net/timowestkamper/querydsl-overview-2014
Slides about older version 3, but except for the fluent API changes the concept is the same.