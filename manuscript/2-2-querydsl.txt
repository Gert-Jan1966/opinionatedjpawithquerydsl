# No further step without Querydsl {#ch-querydls}

D> I do realize I'm breaking a flow of the book a little bit, but since I've been introduced
D> to this neat library I became a huge fan and I never looked back. It doesn't affect JPA itself
D> because it sits above it but in your code it virtually replaces both JPQL and especially
D> Criteria API.

To put it simply -- [Querydsl](http://www.querydsl.com) is a library that -- from programmer's
perspective -- works like a more expressive and readable version of *Java Persistence Criteria
API*. Internally it first generates JPQL and the rest from there is handled by the JPA provider.
Querydsl can actually talk to many more back-ends: SQL, Hibernate directly, ... and many
more, but we will focus on Querydsl over JPA here. To use it goes in these steps:

* declare the dependency for Querydsl library and to its annotation processor,
* add a step in your build to generate metamodel classes,
* and write queries happily in sort of criteria-like way.

But Criteria API also lets you use generated metamodel, so what's the deal? Why would I introduce
non-standard third-party library when it does not provide any additional advantage? If you even
hate this idea, then you probably can stop reading this book -- or you can translate all my
Querydsl code into JPQL or Criteria yourself, which is perfectly doable, of course! Querydsl does
not disrupt the stack under it, it is "just" slapped over the JPA to make it more convenient.

I> Appendix [Project example](#app-project-example) shows the details needed in your build files
I> to set up annotation processor for Querydsl.

Querydsl brings in a [domain-specific language](https://en.wikipedia.org/wiki/Domain-specific_language)
(or DSL) in the form of its fluent API. It happens to be so-called internal DSL because it's still
embedded in Java, it's not different language per se. This fluent API is much more readable and
convenient than Criteria API which has couple of advantages.

DSL is a language of some specific domain -- in this case it's a query language very close to JPQL
or SQL. It builds on a generated metamodel a lot. API of this metamodel is well-though and takes
type-safety to a higher level compared with Criteria API. This not only gives us compile-time
checks for our queries, but also offers even better auto-completion in IDEs.


## Simple example with Querydsl

Let's be concrete now -- but also very simple. We have a class `Dog`, each dog has a `name`
and we will query by this `name`. Assuming we got hold of `EntityManager` (variable `em`) the code
goes like this:

{title="Querydsl simple example", lang=java}
~~~
List<Dog> dogs = new JPAQuery<Dog>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .where(QDog.dog.name.like("Re%"))
//.where(QDog.dog.name.startsWith("Re")) // alternative
  .fetch();
~~~

Both `where` alternatives produce the same result in this case, but `startsWith` may communicate
the intention better, unless you go for `like("%any%")` in which case `contains` would be better.
If you are provided input values for `like`, leave it. If you can tell from the logic that more
specific name for the operation is better, go for it.

This is a very subtle thing, but we can see that this DSL contains variations that can communicate
our intention more clearly. Criteria API sticks to `like` only, because that is its internal model.
Other thing is how beautifully the whole query flows. In version 4.x the fluent API got even closer
to JPQL/SQL semantics, it starts with `select` (what) and ends with `fetch` which is a mere
signal to deliver the results. As with any other fluent API, you need a terminal operation.
In previous versions you would have no `select` because it was included in a terminal operation,
e.g. `list(QDog.dog)`. Newer version is one line longer, but closer to the target domain
of query languages.

D> And yes, I wrap the code like this even in IDE where I could afford 160 characters or more.
D> That, however, is completely different topic and there are people that can explain it [much
D> better](http://www.infoq.com/presentations/7-ineffective-coding-habits).
D> The whole linked presentation is good (and fun!), but at least watch the part from 17m25s.


## Comparison with Criteria API

Both Querydsl and Criteria API are natural fit for dynamic query creation. Doing this with JPQL
is rather painful. Imagine a search form with separate fields for a person
entity, so you can search by name, address, date of birth from--to, etc. We don't want to add
the search condition when the respective input field is empty. If you have done this before
with any form of query string concatenation then you probably know the pain. In extreme cases
of plain JDBC with prepared statement you even have to write all the `if`s twice -- first to add
`where` condition (or `and` for any next one) and second to set parameters. Technically you can
embed the parameter values into the query, but let's help the infamous
[injection](https://en.wikipedia.org/wiki/SQL_injection) vulnerability get off the top of the
[OWASP Top 10 list](https://www.owasp.org/index.php/Top_10_2013-Top_10).

T> If you ever need to construct JDBC statements again -- and there are cases when JPA is not
T> enough, like streaming a really long list of results -- you definitely want to use something like Spring's
T> [`JdbcTemplate`](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/jdbc.html#jdbc-JdbcTemplate).
T> This still leaves putting the query together to you, but allows you to add each parameter
T> value at the time when you add the where part. And also takes away many low-level JDBC concerns.
T>
T> BTW: Do you remember *JPA 1.0*? It didn't have any Criteria API!

Let's see how query for our dogs looks like with Criteria API -- again starting from `em`:

{title="Criteria API simple example", lang=java}
~~~
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Dog> query = cb.createQuery(Dog.class);
Root<Dog> dog = query.from(Dog.class);
query.select(dog)
  // this is the only place where we can use metamodel in this example
  .where(cb.like(dog.get(Dog_.name), "Re%"));
  // without metamodel it would be:
//.where(cb.like(dog.<String>get("name"), "Re%"));
List<Dog> dogs = em.createQuery(query)
  .getResultList();
~~~

Let's observe now:

* First you need to get `CriteriaBuilder` from existing `em`. You might "cache" this into
a field but it may not play well with EE component model, so I'd rather get it before using.
This should not be heavy operation, in most cases entity manager holds this builder already
and merely gives it to you (hence `get` and not `new` or `create`).
* Then you create an instance of `CriteriaQuery`.
* From this you need to get a `Root` object representing content of a `from` clause.
* Then you use the `query` in a nearly-fluent fashion. Version with metamodel is presented
with alternative without it in the comment.
* Finally, you use `em` again to get a `TypedQuery` based on the `CriteriaQuery` and we ask it
for results.

D> Creators of JPA decided not to go with fluent API and it shows. If you read this for a while
D> you'll get the meaning, especially when you're used to it, but our mind needs bigger mental
D> shift to get the meaning compared with the Querydsl version. Clearly, signal-to-noise ratio
D> is much lower too.

While in case of Criteria API you don't need to generate metamodel from the entity classes,
in Querydsl this is not optional. But using metamodel in Criteria API is advantageous anyway
so the need to generate the metamodel for Querydsl using annotation processor can hardly be
considered a drawback. It can be easily integrated with Maven or other build as demonstrated
in the [companion sources](https://github.com/virgo47/opinionatedjpawithquerydsl/blob/master/examples/querydsl-basic/pom.xml)
to this book or [documented](http://www.querydsl.com/static/querydsl/4.0.7/reference/html/ch02.html#d0e127)
on Querydsl site.

For another comparison of Querydsl and Criteria API, you can also check the
[original blog post](http://blog.mysema.com/2010/04/querydsl-as-alternative-to-jpa-2.html)
from 2010. Querydsl was much younger then (version 1.x) but the difference was striking already.


## Comparison with JPQL

Comparing Querydsl with Criteria API was rather easy as they are in the same ballpark. Querydsl,
however, with its fluency can be compared to JPQL as well. After all JPQL is non-Java DSL,
even though it typically is embedded in Java code. Let's see JPQL in action first to finish
our side-by-side comparisons:

{title="JPQL simple example", lang=java}
~~~
List<Dog> dogs = em.createQuery(
  "select d from Dog d where d.name like :name", Dog.class)
  .setParameter("name", "Re%")
  .getResultList();
~~~

This is it! Straight to the point, and you can even call it fluent! Probably the best we can do
with Querydsl is adding one line to introduce shorter "alias" like this:

{title="Querydsl simple example with alias", lang=java}
~~~
QDog d = new QDog("d1");
List<Dog> dogs = new JPAQuery<Dog>(em)
  .select(d)
  .from(d)
  .where(d.name.startsWith("Re"))
  .fetch();
~~~

Using aliases is very handy especially for longer and/or more complicated queries. We could
use `QDog.dog` as the value, or here I introduced new query variable and named it `d1`. This
name will appear in generated JPQL that looks a little bit different from the JPQL in example
above:

~~~
select d1 from Dog d1 where d1.name like ?1 escape '!'
~~~

There is a subtle difference in how Querydsl generates `like` clause -- which, by the way, is fully
customizable using Querydsl templates. But you can see that alias appears in JPQL, although neither
EclipseLink nor Hibernate bother to translate it to the generated SQL for your convenience.

Now, if we compare both code snippets above (alias creation included) we get a surprising result --
there are more characters in the JPQL version! Although it's just a nit-picking (line/char up or
down), it's clear that Querydsl can express JPQL extremely well (especially in 4.x version)
and at the same time it allows for easy dynamic query creation.

If you're familiar with JPQL more than me (which is not that hard, after all) you may ask about
named queries. Here I admit right away, that Querydsl necessarily introduces overhead (see
[cons](#querydsl-cons) section), but when it comes to query reuse from programmer's perspective,
Querydsl offers so called detached queries. While these are not covered in their reference manual
(as of March 2016), we will talk [more about them](#querydsl-detached-queries) in a chapter
about [advanced Querydsl topics](#ch-advanced-querydsl).


## What about the cons? {#querydsl-cons}

Before we move to a couple of advanced topics I'd go over the disadvantages of using Querydsl.
For one, you're definitely adding some overhead. I don't know exactly how big, maybe with the SQL
backend (using JDBC directly) it would be more pronounced because ORM itself is big overhead
anyway. In any case, there is object graph of the query in the memory before it is serialized into
JPQL -- and from there it's on the same baseline like using JPA directly.

This performance factor obviously is not a big deal for many Querydsl users (some of them are
really big names), it mostly does not add too much to the SQL execution itself, but in any case --
if you are interested you have to measure it yourself. Also realize that without Querydsl you
either have to mess with JPQL strings before you have the complete dynamic WHERE part or you should
compare it with Criteria API which does not have to go through JPQL, but also creates some object
graph in the memory (richer or not? depends).

Documentation, while good, is definitely not complete. For instance, detached queries are not
mentioned in their [Query Reference Guide](http://www.querydsl.com/static/querydsl/4.0.7/reference/html_single/)
and there is much more you need to find out yourself. You'll need to find your own best practices,
probably, but it is not that difficult with Querydsl. Based (not only) on my own experience, it
is literally joy to work with Querydsl and explore what it can provide -- for me it worked like
this from day zero. It's also very easy to find responses on the
[stackoverlow](http://stackoverflow.com/questions/tagged/querydsl) or their
[mailing-list](https://groups.google.com/forum/#!forum/querydsl), very often provided directly
by Querydsl developers. This makes any lack of documentation easy to overcome.

Finally, you're adding another dependency to the project, which may be a problem for some. For us
it is well compensated with the code clarity Querydsl gave us.


## Be explicit with aliases

With attribute paths at our disposal it is easy to require some data without explicitly using
joins. Let's consider the following entity chain:

![Class diagram of our entity model](images/querydsl-aliases.png)

We will start all the following queries at `EntityA` and first we will want the list of related
`EntityC` objects. We may approach it like this:

{title="Query with two-level implicit join", lang=java}
~~~
List<EntityC> result = new JPAQuery<>(em)
  .select(QEntityA.entityA.entityB.entityC)
  .from(QEntityA.entityA)
  .fetch();
~~~

This works and Hibernate generates the following SQL:
{title="Generated SQL (formatted)", lang=sql}
~~~
select
  entityc2_.id as id1_5_,
  entityc2_.entityD_id as entityD_3_5_,
  entityc2_.name as name2_5_
from
  EntityA entitya0_,
  EntityB entityb1_ inner join
  EntityC entityc2_ on entityb1_.entityC_id=entityc2_.id
where entitya0_.entityB_id=entityb1_.id
~~~

Effectively these are both inner joins and the result is as expected. But what happens if we
want to traverse to `EntityD`?

{title="Three-level implicit join", lang=java}
~~~
List<EntityD> result = new JPAQuery<>(em)
  .select(QEntityA.entityA.entityB.entityC.entityD)
  .from(QEntityA.entityA)
  .fetch();
~~~

After running this we end up with `NullPointerException` on the line with `select` method. What
happened? The core problem is that it is not feasible to generate infinitely deep path using
final fields. Querydsl offers some solutions to this as [discussed in the reference
documentation](http://www.querydsl.com/static/querydsl/4.1.3/reference/html_single/#d0e2260).
You can either ask the generator to initialize the path you need with the `@QueryInit` annotation
or you can mark the entity with `@Config(entityAccessors=true)` which generates accessor methods
instead of final fields. In the latter case you'd simply use this annotation on `EntityC` and
in the `select` call use `entityD()` which would create the property on the fly. This way you can
traverse relations ad lib. It requires some Querydsl annotations on the entities -- which you may
already use, for instance for custom constructors, etc.

However, instead of customizing the generation I'd advocate being explicit with aliases instead.
If there is a join let it show! We can go around the limitation of max-two-level paths using just
a single join:

{title="Taming deep paths with a join", lang=java}
~~~
List<EntityD> result = new JPAQuery<>(em)
  .select(QEntityB.entityB.entityC.entityD)
  .from(QEntityA.entityA)
  .join(QEntityA.entityA.entityB, QEntityB.entityB)
  .fetch();
~~~

Here we lowered the nesting back to two levels by making `EntityB` explicit. We used existing
default alias `QEntityB.entityB`. This query makes the code run, but looks... unclean, really.
Let's go all the way and make all the joins explicit:

{title="Explicit joins with aliases", lang=java}
~~~
List<EntityD> result = new JPAQuery<>(em)
  .select(QEntityD.entityD)
  .from(QEntityA.entityA)
  // second parameter is alias for the path in the first parameter
  .join(QEntityA.entityA.entityB, QEntityB.entityB)
  // first parameter uses alias from the previous line
  .join(QEntityB.entityB.entityC, QEntityC.entityC)
  .join(QEntityC.entityC.entityD, QEntityD.entityD)
  .fetch();
~~~

Now this looks long, but it says exactly what it does -- no surprises. We may help it in a couple
of ways but the easiest one is to introduce the aliases upfront:

{title="Explicit upfront aliases", lang=java}
~~~
QEntityA a = new QEntityA("a");
QEntityB b = new QEntityB("b");
QEntityC c = new QEntityC("c");
QEntityD d = new QEntityD("d");
List<EntityD> result = new JPAQuery<>(em)
  .select(d)
  .from(a)
  .join(a.entityB, b)
  .join(b.entityC, c)
  .join(c.entityD, d)
  .fetch();
~~~

I like this most -- it is couple of lines longer but very clean and the query is very easy to read.
Anytime I work with joins I always go for explicit aliases.

Another related problem is joining the same entity more times (but in different roles). Newbie
programmers also often fall for a trap of using the same alias -- typically the default one offered
on each Q-class -- for multiple joins on the same entity. There can be two distinct local variables
representing these aliases but they both point to the same object instance -- hence it's still the
same alias. Whenever I join an entity more times in a query I always go for created aliases. When
I'm sure that an entity is in a query just once I may use default alias. It really pays off to
have a strict and clean strategy of how to use the aliases and local variables pointing at them.


## Subqueries {#querydsl-subqueries}

Before checking subqueries, let's see what data we will work on (code
[here](https://github.com/virgo47/opinionatedjpawithquerydsl/blob/master/examples/querydsl-basic/src/test/java/tests/Subqueries.java)).

{title="Breed", width="narrow"}
| id | name |
-------------
| 1 | collie |
| 2 | german shepherd |
| 3 | retriever |

{title="Dog (id is not important)", width="narrow"}
| name | age | breed_id |
----------------------
| Lassie | 7 | 1 (collie) |
| Rex | 6 | 2 (german shepherd) |
| Ben | 4 | 2 (german shepherd) |
| Mixer | 3 | null (unknown breed) |


### Independent subquery

If we want to find all the dogs that are of breed with a long name, we can do this:
{title="Dogs with a long breed name", lang=java}
~~~
List<Dog> dogsWithLongBreedName = new JPAQuery<>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .where(QDog.dog.breed.in(
    new JPAQuery<>() // no EM here
      .select(QBreed.breed)
      .from(QBreed.breed)
      // no fetch on subquery
      .where(QBreed.breed.name.length().goe(10))))
  .fetch();
~~~

This returns Ben and Rex, both german shepherds. Note that subquery looks like normal query, but
we don't provide `EntityManager` to it and we don't use any `fetch`. If you do the subquery will
be executed on its own first and its results will be fetched into `in` clause just as any other
collection would. This is not what we want in most cases -- especially when the code leads us to
an idea of a subquery. The previous result can be achieved with join as well -- and in such cases
joins are almost always preferable.

Another example finds average age of all dogs and returns only those above it:
{title="Dogs older than average", lang=java}
~~~
List<Dog> dogsOlderThanAverage = new JPAQuery<>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .where(QDog.dog.age.gt(
    new JPAQuery<>()
      .select(QDog.dog.age.avg())
      .from(QDog.dog)))
  .fetch();
~~~

In both cases the same result can be obtained when we execute the inner query first because it
always provides the same result. Second case is perhaps on the edge, because it uses the same
`QDog.dog` alias for both cases, but I dare to say it does not matter here.


### Correlated subquery

Let's see some more interesting subquery. We want to know for what breeds we have no dogs:
{title="Breeds with no dogs", lang=java}
~~~
List<Breed> breedsWithoutDogs = new JPAQuery<>(em)
  .select(QBreed.breed)
  .from(QBreed.breed)
  .where(
    new JPAQuery<>()
      // select not needed here, because of exists
      .from(QDog.dog)
      .where(QDog.dog.breed.eq(QBreed.breed))
      .notExists())
  .fetch();
~~~

We used a subquery with `exist/notExists` and we could omit `select`, although it can be used.
This returns a single breed -- *retriever*. Interesting aspect is that the inner query uses
something from the outer select (here `QBreed.breed`), that's why it's called *correlated*
subquery. Compared to the subqueries from the previous section this one can have different
result for each row of the outer query.

This can actually be done by join, as well, but in this case I'd not recommend it. Depending on
the mapping you use, various things work on various providers. When you map `@ManyToOne Breed
breed` than this works on EclipseLink:
{title="Breeds with no dogs", lang=java}
~~~
List<Breed> result = new JPAQuery<>(em)
  .select(QBreed.breed)
  .from(QBreed.breed)
  .leftJoin(QDog.dog).on(QBreed.breed.eq(QDog.dog.breed))
  .where(QDog.dog.isNull())
  .distinct() // not needed for isNull, only for isNotNull
  .fetch();
~~~

Alas, it fails on Hibernate (5.2.2) with `InvalidWithClauseException: with clause can only
reference columns in the driving table`. It seems to be an open bug mentioned in (this StackOverflow
answer)[http://stackoverflow.com/a/26527967/658826] -- and the suggested solution of using plain
keys instead of objects indeed work:
~~~
// the rest is the same
.leftJoin(QDog.dog).on(QBreed.breed.id.eq(QDog.dog.breedId))
~~~

For this we need to switch `Breed breed` mapping to plain FK mapping, or use both of them with
one marked with updatable `false`:
~~~
@Column(name = "breed_id", updatable = false, insertable = false)
private Integer breedId;
~~~

If you add mapping for set of all dogs existing for a breed -- which may be rather superfluous
(there is always a query for it) you can use very natural query:
~~~
List<Breed> xxx = new JPAQuery<>(em)
  .select(QBreed.breed)
  .from(QBreed.breed)
  .where(QBreed.breed.dogs.isEmpty())
  .fetch();
~~~

Internally this generates subquery with count or (not) exists anyway.

Finally, let's try to find dogs that are older than average -- but this time for each breed:
{title="Dogs older than breed average", lang=java}
~~~
QDog innerDog = new QDog("innerDog");
List<Dog> dogsOlderThanBreedAverage = new JPAQuery<>(em)
  .select(QDog.dog)
  .from(QDog.dog)
  .where(QDog.dog.age.gt(
    new JPAQuery<>()
      .select(innerDog.age.avg())
      .from(innerDog)
      .where(innerDog.breed.eq(QDog.dog.breed))))
  .fetch();
~~~

Notice the use of `innerDog` alias which is very important. Had you use `QDog.dog` in the subquery
it would return the same results like `dogsOlderThanAverage` above. This query returns only Rex,
because only german shepherds have more than a single dog -- and a single (or no) dog can't be
older than average.

This section is not about going deep into subquery theory (I'm not the right person for it in the
first place), but to demonstrate how easy and readable it is to write subqueries with Querydsl
API. You're limited by JPQL (no subqueries in `from` or `select` clauses), of course. When writing
subqueries be careful not to "reuse" alias from the outer query.


## Aggregate functions {#querydsl-aggregation}

TODO


## Pagination

TODO


## Tuple for rows

TODO


## Fetching *to-many* eagerly

TODO


## Querydsl and code style

TODO: using $, static imports, when to use/not use them

## More

http://www.slideshare.net/timowestkamper/querydsl-overview-2014
Slides about older version 3, but except for the fluent API changes the concept is the same.
See also chapter with [advanced Querydsl topics](#ch-advanced-querydsl).